.. change::
    :tags: bug, regression, orm
    :tickets: 6206

    Fixed critical regression where the :meth:`_orm.Query.yield_per` method in
    the ORM would set up the internal :class:`_engine.Result` to yield chunks
    at a time, however made use of the new :meth:`_engine.Result.unique` method
    which uniques across the entire result. This would lead to lost rows since
    the ORM is using ``id(obj)`` as the uniquing function, which leads to
    repeated identifiers for new objects as already-seen objects are garbage
    collected. 1.3's behavior here was to "unique" across each chunk, which
    does not actually produce "uniqued" results when results are yielded in
    chunks. As the :meth:`_orm.Query.yield_per` method is already explicitly
    disallowed when joined eager loading is in place, which is the primary
    rationale for the "uniquing" feature, the "uniquing" feature is now turned
    off entirely when :meth:`_orm.Query.yield_per` is used.

    This regression only applies to the legacy :class:`_orm.Query` object; when
    using :term:`2.0 style` execution, "uniquing" is not automatically applied.
    To prevent the issue from arising from explicit use of
    :meth:`_engine.Result.unique`, an error is now raised if rows are fetched
    from a "uniqued" ORM-level :class:`_engine.Result` if any
    :ref:`yield per <orm_queryguide_yield_per>` API is also in use, as the
    purpose of ``yield_per`` is to allow for arbitrarily large numbers of rows,
    which cannot be uniqued in memory without growing the number of entries to
    fit the complete result size.

