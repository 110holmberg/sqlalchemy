.. change::
    :tags: bug, engine, regression
    :tickets: 6218

    Fixed up the behavior of the :class:`_result.Row` object when dictionary
    access is used upon it, meaning converting to a dict via ``dict(row)`` or
    accessing members using strings or other objects i.e. ``row["some_key"]``
    works as it would with a dictionary, rather than raising ``TypeError`` as
    would be the case with a tuple, whether or not the C extensions are in
    place. This was originally supposed to emit a 2.0 deprecation warning for
    the "non-future" case using :class:`_result.LegacyRow`, and was to raise
    ``TypeError`` for the "future" :class:`_result.Row` class. However, the C
    version of :class:`_result.Row` was failing to raise this ``TypeError``,
    and to complicate matters, the :meth:`_orm.Session.execute` method now
    returns :class:`_result.Row` in all cases to maintain consistency with the
    ORM result case, so users who didn't have C extensions installed would
    see different behavior in this one case for existing pre-1.4 style
    code.

    Therefore, in order to soften the overall upgrade scheme as most users have
    not been exposed to the more strict behavior of :class:`_result.Row` up
    through 1.4.6, :class:`_result.LegacyRow` and :class:`_result.Row` both
    provide for string-key access as well as support for ``dict(row)``, in all
    cases emitting the 2.0 deprecation warning when ``SQLALCHEMY_WARN_20`` is
    enabled. The :class:`_result.Row` object still uses tuple-like behavior for
    ``__contains__``, which is probably the only noticeable behavioral change
    compared to :class:`_result.LegacyRow`, other than the removal of
    dictionary-style methods ``values()`` and ``items()``.
